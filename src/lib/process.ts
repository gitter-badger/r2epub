/**
 * Main processing steps for the creation of EPUB files. See [[process]] for the details.
 */

import * as jsdom      from 'jsdom';
import * as _          from 'underscore';
import * as urlHandler from 'url';

import { fetch_html, fetch_resource, fetch_type, xhtml_media_type, URL } from './fetch';
import * as package_document from './package_document';
import * as css              from './css';
import * as cover            from './cover';
import * as nav              from './nav';
import * as ocf              from './ocf';
import * as create_xhtml     from './create_xhtml';


/**
 * Interface for the resources that, eventually, should be added to the EPUB file
 */
export interface ResourceRef {
    /** The URL to be used within the EPUB; relative to the top of the file */
    relative_url   :URL,

    /** Media type of the resource; this must be added to the package manifest entry */
    media_type     :string,

    /** URL of the resource in case it must be fetched */
    absolute_url?  :URL,

    /** Content of the resource in case it is generated by this program */
    text_content?  :string,

    /** The item must have a fixed id, rather than a generated one */
    id?            :string,

    /** Extra properties, defined by the package specification, to be added to the entry */
    properties?    :string
}


/** Interface of the "Global" data, to be used by various utilities */
export interface Global {
    /** The URL of the document to be processed */
    document_url? :string,

    /** The DOM element, as returned from parsing */
    dom?          : jsdom.JSDOM,

    /** The DOM HTML element of the main document */
    html_element? :Element,

    /**
     * The  initial config object, originally filled by the user (respec puts a copy of this
     * object, as JSON, into the header of the generated content.
    */
    config?       :any,

    /**
     * The class used for the generation of the EPUB opf file
     */
    package?      :package_document.PackageWrapper

    /**
     * List of extra resources, to be added to the opf file and into the final EPUB file. The main role of the [[process]]
     * function is to collect all relevant resources; once done, this array is used to generate the final
     * [`package.opf`](https://www.w3.org/publishing/epub32/epub-packages.html#sec-package-def) file
     * as well as to collect the resources themselves and add them to the final epub file.
     */
    resources?    :ResourceRef[]
}

/**
 * Interface for the HTML DOM elements, to be considered for possible internal references.
 */
interface LocalLinks {
    /** CSS selector to locate the right DOM elements */
    query :string,
    /** Attribute name to extract the resource URL */
    attr  :string
}

/**
 * Arrays of query/attribute pairs that may refer to a resource to be collected:
 *
 * - image elements
 * - `a` elements
 * - links to stylesheets
 * - `object` elements
 */
const resource_references :LocalLinks[] = [
    {
        query : 'img',
        attr  : 'src'
    },
    {
        query : 'a',
        attr  : 'href'
    },
    {
        query : 'link[rel="stylesheet"]',
        attr  : 'href'
    },
    {
        query : 'object',
        attr  : 'data'
    },
    {
        query : 'script',
        attr  : 'src'
    }
]

/**
 * Main processing steps:
 *
 * 1. Gather all the global information ([[Global]])
 * 2. Add the basic metadata (authors, dates) to the opf file
 * 3. Collect all the resources (see [[resource_references]]); the relative urls and the media types are all
 * added to [[global]], to be added to the EPUB file and the opf file later
 * 4. Add the reference to the W3C logo
 * 5. Add the reference to the generic fixup script.
 * 6. Add some of the global W3C CSS files, and auxillary image files
 * 7. Create a cover file
 * 8. Create a nav file
 * 9. Main resource (i.e., Overview.xhtml) entry, with relevant properties
 * 10. Finalize the package file based on the collected resources in [[Global.resources]]
 * 11. Download all resources into the EPUB file
 *
 * All the entries are collected in the in a [[Global.resources]] array, to be then added to the
 * [`package.opf`](https://www.w3.org/publishing/epub32/epub-packages.html#sec-package-def) file as well as to download
 * the resources into the final epub result.
 *
 * @param document_url - The URL for the (generated) file
 * @async
 */
export async function process(document_url: string) {

    // ------------------------------------------
    // 1. Get hold of the local information
    const global :Global = {
        document_url : document_url,
        resources : []
    }

    {
        // get hold of the document as a DOM node.
        global.dom          = await fetch_html(document_url);
        global.html_element = global.dom.window.document.documentElement;
    }

    {
        // Get hold of the configuration information
        const initial_config_element = global.html_element.querySelector("script#initialUserConfig") as HTMLScriptElement;
        if( initial_config_element === null ) {
            throw "User config is not available"
        } else {
            global.config = JSON.parse(initial_config_element.textContent);
        }
    }

    // ------------------------------------------
    // 2. Add the basic metadata (authors, dates) to the opf file
    {
        // Create the package content, and populate it with the essential metadata using the configuration
        const title = global.html_element.querySelector('title').textContent;
        const identifier = `https://www.w3.org/TR/${global.config.shortName}/`;
        global.package = new package_document.PackageWrapper(identifier, title);
        global.package.add_creators(global.config.editors.map((entry: any) => `${entry.name}, ${entry.company}`));

        const date = global.html_element.querySelector('time.dt-published');
        global.package.add_dates(date.getAttribute('datetime'));
    }

    // ------------------------------------------
    // 3. Collect all the extra resources from the Overview.html file
    global.resources = await get_extra_resources(global);

    // ------------------------------------------
    // 4. Add the reference to the W3C logo
    {
        const logo_element = global.html_element.querySelector('img[alt="W3C"]');
        if (logo_element !== null) {
            const relative_url = 'StyleSheets/TR/2016/logos/W3C.svg';
            logo_element.setAttribute('src', relative_url);
            // There is an ugly story here. The SVG version of the logo, as stored on the W3C site, includes a reference
            // the very complex SVG DTD, and epubcheck does not like it (EPUB v. 3 does not like it, I guess). So
            // I created a version of the logo without it and stored it at a fix URL...
            global.resources.push({
                relative_url : relative_url,
                media_type   : 'image/svg+xml',
                absolute_url : 'https://www.w3.org/People/Ivan/StyleSheets/W3C_TR_2016.svg'
            })
        }
    }

    // ------------------------------------------
    // 5. Add the reference to the generic fixup script. I am not sure it is really necessary
    // but it may not harm...
    {
        const fixup_element = global.html_element.querySelector('script[src="https://www.w3.org/scripts/TR/2016/fixup.js"]');
        if (fixup_element !== null) {
            const relative_url = 'scripts/TR/2016/fixup.js';
            fixup_element.setAttribute('src', relative_url);
            global.resources.push({
                relative_url : relative_url,
                media_type   : 'text/javascript',
                absolute_url : 'https://www.w3.org/scripts/TR/2016/fixup.js'
            })
        }
    }

    // ------------------------------------------
    // 6. Add some of the global W3C CSS files, and auxillary image files
    global.resources = [...global.resources, ...css.extract(global)]

    // ------------------------------------------
    // 7. Create a cover file
    global.resources = [...cover.create_cover_page(global), ...global.resources, ];

    // ------------------------------------------
    // 8. Create a nav file
    global.resources = [...nav.create_nav_file(global), ...global.resources];

    // ------------------------------------------
    // 9. Add main resource (i.e., Overview.xhtml) entry, with relevant properties
    global.resources = [...generate_overview_item(global), ...global.resources];

    // ------------------------------------------
    // 10. Finalize the package file
    {
        // Populate the global package with the resource item
        let res_id_num = 1;
        global.resources.forEach((resource) => {
            if (resource.relative_url) {
                global.package.add_manifest_item({
                    "@href"       : resource.relative_url,
                    "@media-type" : resource.media_type,
                    "@id"         : resource.id || `res_id${res_id_num}`,
                    "@properties" : resource.properties
                });
                res_id_num++;
            }
        })
    }

    // console.log(global.package.serialize())
    // 11. Download all resources into the EPUB file
    await generate_epub(global);
}


/**
 * Collect the references to the extra resources, to be added to the EPUB file as well as the package opf file.
 * It relies on searching through the HTML source file, based on the query patterns given in [[resource_references]].
 *
 * @param global - global data
 * @returns - list of additional resources
 * @async
 */
const get_extra_resources = async (global: Global): Promise<ResourceRef[]> => {
    // Collect the set of resources from relative links in the source
    // The 'resource_references' array gives the pair of CSS query and attribute names to consider as
    // local resources. Those are collected in one array.
    const target_urls = _.chain(resource_references)
        // extract the possible references
        .map((ref :LocalLinks) => {
            const candidates = Array.from(global.html_element.querySelectorAll(ref.query));
            return candidates.map((element) => element.getAttribute(ref.attr));
        })
        // create one single array of the result (instead of an array or arrays)
        .flatten()
        // Remove absolute URL-s
        .filter((ref) => {
            if (ref !== '' && ref !== null) {
                const parsed = urlHandler.parse(ref);
                // Relative URL means that the protocol is null
                return parsed.protocol === null && parsed.path !== null;
            } else {
                return false;
            }
        })
        // Remove fragment part, if any
        .map((ref) => {
            const parsed = urlHandler.parse(ref);
            parsed.hash = null;
            return urlHandler.format(parsed);

        })
        .value();

    // Ensure that the list is duplicate free
    // (Why couldn't I put this into the chain???)
    const relative_urls = _.uniq(target_urls);
    const absolute_urls = relative_urls.map((ref :string) :string => urlHandler.resolve(global.document_url, ref));
    const media_types   = await Promise.all(absolute_urls.map((url) => fetch_type(url)));

    return _.zip(relative_urls, media_types, absolute_urls).map((entry: string[]) :ResourceRef => {
        return {
            relative_url : entry[0],
            media_type   : entry[1],
            absolute_url : entry[2],
        }
    });
}


/**
 * Create the final epub file: download all resources, if applicable, and then add all of them, plus the
 * generated content (package file, nav file, the original content file, etc) to an OCF instance.
 *
 * The generated epub file name is `shortName.epub`
 *
 * @param global - Global data
 * @async
 */
const generate_epub = async (global: Global) => {
    const the_book = new ocf.OCF(`${global.config.shortName}.epub`);

    // The OCF class adds the fixed file like mime type and such automatically.
    // Add the package to the archives, with a fixed name:
    the_book.append(global.package.serialize(),'package.opf');

    // Add all the resources
    {
        // First, find the resources where the content is simply a text; this can be archived directly
        global.resources
            .filter((resource: ResourceRef): boolean => resource.text_content ? true : false)
            .forEach((resource: ResourceRef): void => the_book.append(resource.text_content, resource.relative_url));

        // Second, find the resources where the content must be fetched...
        const to_be_fetched = global.resources.filter((resource: ResourceRef): boolean => resource.absolute_url ? true : false);
        const file_names = to_be_fetched.map((resource :ResourceRef): URL => resource.relative_url);
        const urls       = to_be_fetched.map((resource :ResourceRef): URL => resource.absolute_url);
        const contents   = await Promise.all(urls.map((url: URL): Promise<any> => fetch_resource(url)));
        _.zip(contents, file_names).forEach((arg: [any,string]) :void => the_book.append(arg[0], arg[1]));
    }

    await the_book.finalize();
}


/**
 * Generate the resource entry for the Overview.xhtml item into the package; that includes setting the various manifest item
 * properties, see [manifest item properties](https://www.w3.org/publishing/epub32/epub-packages.html#app-item-properties-vocab).
 *
 * The following properties are set, if applicable:
 *
 * - [mathml](https://www.w3.org/publishing/epub32/epub-packages.html#sec-mathml): there is an explicit usage of mathml
 * - [remote-resource](https://www.w3.org/publishing/epub32/epub-packages.html#sec-remote-resources): whether there are remote resources. This is set by default: virtually any document has just resources, e.g., license, references...
 * - [scripted](https://www.w3.org/publishing/epub32/epub-packages.html#sec-scripted): there are active scripts
 * - [svg](https://www.w3.org/publishing/epub32/epub-packages.html#sec-svg): there is explicit svg usage
 *
 * @param global - Global data
 * @return - a single element array with the resource definition of the `Overview.xhtml` entry
 */
const generate_overview_item = (global: Global): ResourceRef[] => {
    const retval :ResourceRef = {
        media_type   : 'application/xhtml+xml',
        id           : 'main',
        relative_url : 'Overview.xhtml',
        text_content : create_xhtml.convert_dom(global.dom)
    }

    const properties = ['remote-resources'];

    // 1. Mathml usage
    if (global.html_element.querySelector('mathml') !== null) {
        properties.push('mathml');
    }

    // 2. are there active scripts
    const scripts = Array.from(global.html_element.querySelectorAll('script'));
    const is_there_script = scripts.find((element: HTMLScriptElement): boolean => {
        if (element.hasAttribute('type')) {
            const type = element.getAttribute('type');
            return ['application/javascript', 'application/ecmascript', 'text/javascript', 'text/ecmascript'].includes(type);
        } else {
            return true;
        }
    })
    if (is_there_script) {
        properties.push('scripted');
    }

    // 3. explicit svg usage
    if (global.html_element.querySelector('svg') !== null) {
        properties.push('svg');
    }

    retval.properties = properties.join(' ');
    return [retval];
}
